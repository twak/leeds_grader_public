//
// Created by twak on 14/10/2019.
// DO NOT EDIT THIS FILE
//

#include "screenshot.h"
#include <sys/stat.h>
#include <fstream>
#include <QApplication>
#include <string>
#include <sys/types.h>
#include <QScrollArea>
#include <QtWidgets>
#include <iostream>
#include <set>

#if defined(_WIN32)
#include <direct.h>
#endif

void Screenshot::scrollAll(QObject *root, bool bottom, std::set<std::string>* labels, int* numberOfResults) {

    int texts = 0, images = 0;

    for (auto qw : root->findChildren<QObject*>() ) {

        QScrollArea * sa= dynamic_cast<QScrollArea*>(qw);
        if (sa) {
            if (bottom)
                sa ->verticalScrollBar()->setValue(sa->verticalScrollBar()->maximum());
            else
                sa ->verticalScrollBar()->setValue(0);
        }

        ResponsiveLabel * ra = dynamic_cast<ResponsiveLabel*>(qw);

        if (ra)
        {
            if (ra->size().width() > 0 && ra->height() > 0 && ra->x() >= 0 && ra->y() >= 0) {

                labels->emplace(ra -> text().toUtf8().constData() );

                if (ra->text().compare(kSResultText) == 0)
                    texts++;

                if (ra->text().compare(kSResultImage) == 0)
                    images++;
            }
        }
    }

    (*numberOfResults) = std::max ( texts, images );
}

// assessment class. do not edit.
void Screenshot::doScreenshot() {

    auto active_window = QApplication::activeWindow();

    QSize &size = remaining.at(0);

    // screen shot currently sized window
    if (active_window) {


        {
            std::set<std::string> labels;
            int results = 0;
            scrollAll(this, remaining.size() % 2 == 0, &labels, &results);
            html << "<tr><td><img width = \"400px\" src=\"" << "images/rendered" +  std::to_string ( size.width() ) + "x" + std::to_string ( size.height() ) +".png\"/><br/>rendered: " << size.width() << "x" << size.height() << "<br/> used: " << labels.size() << " results: " << results <<  " </td>" << std::endl;
        }
        QPixmap pixmap(active_window->size());
        active_window->render(&pixmap);

        std::string s = "./images/rendered" +  std::to_string ( size.width() ) + "x" + std::to_string ( size.height() ) +".png";
        QFile file( QString::fromStdString(s));

        file.open(QIODevice::WriteOnly);
        pixmap.save(&file, "PNG");
    }


    html << "<td><img width = \"400px\" src=\"" << "report/images/rendered" +  std::to_string ( size.width() ) + "x" + std::to_string ( size.height() ) +".png\"/><br/>submitted: " << size.width() << "x" << size.height() << "<br/><br/>&nbsp </td></tr>" << std::endl;

    remaining.erase(remaining.begin(), remaining.begin()+1);

    schedule();
}

void mkdir_ (std::string sPath) {  // https://stackoverflow.com/a/35109823/708802
//    int nError = 0;
    #if defined(_WIN32)
      _mkdir(sPath.c_str()); // can be used on Windows
    #else
      mkdir(sPath.c_str(), S_IRWXU); // can be used on non-Windows
    #endif
//    if (nError != 0) {
//      cout << "error creating directory "<< sPath <<". quitting.";
//      exit (-2);
//    }
}

// when we are shown for the first time, set the screenshot sizes and call the scheduler
void Screenshot::showEvent(QShowEvent *) {

    mkdir_( srcLocation + "/images");

    // tom may add additional sizes to this list when grading...

    remaining.push_back(QSize(320,320));

    remaining.push_back(QSize(568,320));
    remaining.push_back(QSize(320,568));
    
    remaining.push_back(QSize(812,375));
    remaining.push_back(QSize(375,720));

    remaining.push_back(QSize(1024,600));
    remaining.push_back(QSize(1280,720));

    remaining.push_back(QSize(720 ,720));
    remaining.push_back(QSize(500 ,720));

    remaining.push_back(QSize(1280,320));

    remaining.push_back(QSize(320,320));
    remaining.push_back(QSize(512,375));
    remaining.push_back(QSize(918,400));
    remaining.push_back(QSize(1280,324));
    remaining.push_back(QSize(320,720));
    remaining.push_back(QSize(500,500));
    remaining.push_back(QSize(500,510));
    remaining.push_back(QSize(510,500));

    html.open(srcLocation+"/submission.html", std::fstream::in | std::fstream::out | std::fstream::app);

    html << "</pre><h3>Responsive Layouts</h3>" << std::endl;

    html << "<table>";

    schedule();
}

// schedule the next sized screenshot from the remaining list.
void Screenshot::schedule() {
    if (remaining.size() == 0) {

        html << "</table>";
        html.close();

        QApplication::quit();
        return;
    }

    QSize &size = remaining.at(0);
    resize(size);

    mTimer = new QTimer(NULL);
    mTimer->setSingleShot(true);
    mTimer->setInterval(200);
    mTimer->start();

    connect( mTimer, SIGNAL (timeout()), SLOT ( doScreenshot() ) );
}

